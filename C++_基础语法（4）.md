### 常引用

```c++
// 常引用
int main()
{
	// 权限放大 不行
	//const int a = 10;
	//int& b = a;

	// 权限不变 可以
	const int a = 10;
	const int& b = a;

	// 权限缩小 可以
	int c = 10;
	const int& d = c;
    
   	// 不同类型变量之间的引用
	double d = 11.11;
	// int& d1 = d; 这样不行
	const int& d2 = d; // 这样可以 
	// 因为类型不同，存在整型提升，所以先把d拷贝给一个临时变量，然后再给临时变量取别名为d2，临时变量为右值，具有常性，所以加const就可以

	return 0;
}
```

### 注意

- 临时变量为右值，具有常性。

- 不同类型变量之间赋值或者比较大小，都不是一次性完成的，而是先整型提升，存到一个临时变量中，然后再赋值。

- 右值一般是不能修改的值，比如说表达式的返回值、临时变量
- const Type& 可以接收所有类型

### 指针和引用的区别

1. 引用在概念上就是一个变量的别名 vs 指针存储一个变量的地址
2. 引用在定义时必须初始化 vs 指针最好初始化，但是不初始化也没错（也可以编译过）
3. 引用定义是初始化引用一个实体后不能再引用其他实体 vs 指针可以任意指向同类的一个实体。（引用从一而终，指针像极了渣男）
4. 没有NULL引用 vs 有NULL指针
5. 在sizeof中：引用的结果为引用类型的大小 vs 指针的大小始终为4个字节（32）或者8个字节（64）
6. 引用自加是引用的实体自加 vs 指针自加是向后偏移一个所指向类型大小的位置
7. 引用比指针安全一点，指针的使用更危险。

==汇编代码==



<img src="C:\Users\AKANG\Desktop\编程\Image\image-20220920172127864.png" alt="image-20220920172127864" style="zoom:50%;" />

引用的底层是用汇编实现的，但是在语法层面是完全不同的。汇编代码仅作了解即可。



==引用与指针==

```c++
int main()
{
	int a = 10;

	int& b = a;

	int* p = &a;

	b = 2;
	*p = 3;

	cout << a << endl;
	cout << b << endl;
	cout << *p << endl;
	// a b *p 都是同一个值

	cout << &a << endl;
	cout << &b << endl;
	cout << p << endl;
	// &a &b p 都是同一个地址

	return 0;
}
```
